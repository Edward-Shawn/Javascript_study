<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      // 콜백함수
      // 자바스크립트는 비동기 처리가 끝났다는걸 콜백 함수로 알려줌, 즉 콜백 함수를 사용하는게 자바스크립트의
      // 기본적인 비동기 처리방식임

      // 콜백함수가 문제가 되는 시점
      // 의존성이 없으면 문제가 없느나 콜백 함수들 끼리 의존성을 갖게된다면 콜백헬이 발생함
      // 의존하고 있는 상위 콜백에서 문제가 생기면 콜백헬이 발생하며 가독성이 떨어지고
      // 선형구조가 아닌 비선형적인 코드형태로 되어서 개발 비용증가

      // 자바스크립트에서 콜백함수의 의존성 문제를 해결하기위해 promise를 제공함

      // promise 구조
      {
        const promise = new Promise((resolve, reject) => {
          const success = true;
          if (success) {
            resolve("성공"); // 아무값이나 가능
          } else {
            reject(new Error("오류")); // reject에서는 에러객체를 던져주는게 좋음
          }
        });
      }

      // promise의 then
      {
        const promise = new Promise((resolve, reject) => {
          //   resolve("데이터 입니다");
          reject(new Error("에러발생"));
        });
        // resolve의 인자값을 then메서드의 콜백함수에 인자값으로 전달

        // promise.then( // then메서드에는 성공, 실패의 메서드를 담을 수 있음
        // // 그러나 이 메서드 한곳에서 전부다 처리를 한다면 나중에 코드관리가 어려워 질 수 있음
        //   (value) => console.log(value),
        //   (error) => console.error(error)
        // );

        // then메서드에서 전부 관리하는것, 코드 파악의 어려움이 있기 때문에 catch라는 메서드를 제공함
        promise
          .then((value) => {
            // then은 성공시
            console.log(value);
          })
          .catch((error) => {
            // catch는 실패시
            console.error(error);
          })
          // 그리고 성공 실패 여부를 떠나서 항상 호출되는것이 finally 메서드
          .finally(() => {});
      }
    </script>
  </body>
</html>
